############################################################################
#   This file is part of the aGrUM/pyAgrum library.                        #
#                                                                          #
#   Copyright (c) 2005-2025 by                                             #
#       - Pierre-Henri WUILLEMIN(_at_LIP6)                                 #
#       - Christophe GONZALES(_at_AMU)                                     #
#                                                                          #
#   The aGrUM/pyAgrum library is free software; you can redistribute it    #
#   and/or modify it under the terms of either :                           #
#                                                                          #
#    - the GNU Lesser General Public License as published by               #
#      the Free Software Foundation, either version 3 of the License,      #
#      or (at your option) any later version,                              #
#    - the MIT license (MIT),                                              #
#    - or both in dual license, as here.                                   #
#                                                                          #
#   (see https://agrum.gitlab.io/articles/dual-licenses-lgplv3mit.html)    #
#                                                                          #
#   This aGrUM/pyAgrum library is distributed in the hope that it will be  #
#   useful, but WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,          #
#   INCLUDING BUT NOT LIMITED TO THE WARRANTIES MERCHANTABILITY or FITNESS #
#   FOR A PARTICULAR PURPOSE  AND NONINFRINGEMENT. IN NO EVENT SHALL THE   #
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER #
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,        #
#   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  #
#   OTHER DEALINGS IN THE SOFTWARE.                                        #
#                                                                          #
#   See LICENCES for more details.                                         #
#                                                                          #
#   SPDX-FileCopyrightText: Copyright 2005-2025                            #
#       - Pierre-Henri WUILLEMIN(_at_LIP6)                                 #
#       - Christophe GONZALES(_at_AMU)                                     #
#   SPDX-License-Identifier: LGPL-3.0-or-later OR MIT                      #
#                                                                          #
#   Contact  : info_at_agrum_dot_org                                       #
#   homepage : http://agrum.gitlab.io                                      #
#   gitlab   : https://gitlab.com/agrumery/agrum                           #
#                                                                          #
############################################################################

import os
import platform
from datetime import datetime
import time

from .utils import *

from .ActBuilder import ActBuilder


def test_name(filename: str) -> str:
  """
  Extract the test name from a file name.
  """
  return filename.replace("\\", "/").split("/")[-1].split("TestSuite")[0]


def test_names(testsList) -> set[str]:
  return {test_name(s) for s in testsList}


def print_tests_for_module(m):
  print("═" * 110)
  notif(f" [{m} ")
  print("═" * 110)

  l = test_names(
    {
      cross_platform_rel_path(testname, "src/testunits")
      for testname in glob.glob(f"src/testunits/module_{m.upper()}/*TestSuite.h")
    }
  )

  w = max([len(x) for x in l])
  nbr = 80 / w
  i = 0
  print("┃ ", end="")
  for s in sorted(l):
    print(s.ljust(w), end="\t")
    i += 1
    if i > nbr:
      i = 0
      print("\n┃ ", end="")
  if i != 0:
    print("")
  print("")


def print_tests(modules):
  for modul in modules:
    print_tests_for_module(modul)


def write_test_list(l):
  l.sort(key=lambda s: s.split("/")[-1])
  today = datetime.now()
  f = open("src/testunits/testList.cmake", "w")
  f.write("# file automatically generated by act\n")
  f.write("# " + today.strftime("%A, %d. %B %Y %H:%M") + "\n")
  f.write("# do not change it\n")
  f.write("set(AGRUM_TESTS \n  ")
  f.write("\n  ".join(l))
  f.write("\n)\n")
  f.close()
  f = open("src/testunits/testList.all", "w")
  f.write("# file automatically generated by act\n")
  f.write("# " + today.strftime("%A, %d. %B %Y %H:%M") + "\n")
  f.write("# do not change it\n")
  f.write("set(AGRUM_TESTS \n  ")
  f.write("\n  ".join(l))
  f.write("\n)\n")
  f.close()


class ActBuilderAgrum(ActBuilder):
  def __init__(self, current: dict[str, str | bool]):
    super().__init__(current)

  def check_consistency(self) -> bool:
    match self.current["modules"].lower():
      case "all":
        self.modules = set(cfg.modules.keys())
      case "quick":
        self.modules = {"BASE", "BN"}
      case _:
        self.modules = setifyString(self.current["modules"])
        if not self.modules <= set(cfg.modules.keys()):
          error(f"Modules [{self.current['modules']}] not supported. 'all' is selected by default.")
          self.modules = set(cfg.modules.keys())

    if self.current["tests"] == "list":
      print_tests(self.modules)
      return False

    if self.current["action"] == "test":
      alltests = {
        test_name(testname): cross_platform_rel_path(testname, "src/testunits")
        for mn in self.modules
        for testname in glob.glob(f"src/testunits/module_{mn.upper()}/*TestSuite.h")
      }
      if self.current["tests"] != "all":
        asked_tests = setifyString(self.current["tests"])
        missing = asked_tests - set(alltests.keys())
        if len(missing) > 0:
          error(f"Tests [{missing}] not present. Please select 'all' or [-t list] to list all tests.")
          return False
        alltests = {k: alltests[k] for k in alltests.keys() if k in asked_tests}

      notif("Updating test(s) declaration.")
      write_test_list(list(alltests.values()))

    if not self.check_compiler_and_maker():
      return False

    return True

  def build_cmake(self):
    line = cfg.cmake + " ../../.."  # we are in build/target/[release|debug]

    line += " -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"  # for clang-tidy

    if self.current["mode"] == "Release":
      line += " -DCMAKE_BUILD_TYPE=RELEASE"
    else:
      line += " -DCMAKE_BUILD_TYPE=DEBUG"

    if self.current["withSQL"]:
      line += " -DUSE_NANODBC=ON"
    else:
      line += " -DUSE_NANODBC=OFF"

    line += " -DCMAKE_INSTALL_PREFIX=" + '"' + self.current["destination"] + '"'

    # defaults to lib64 on manylinux images
    if "Linux" in platform.system():
      line += " -DCMAKE_INSTALL_LIBDIR=lib"

    if self.current["verbose"]:
      line += " -DCMAKE_VERBOSE_MAKEFILE=ON"
    else:
      line += " -DCMAKE_VERBOSE_MAKEFILE=OFF"

    if self.current["static_lib"]:
      line += " -DBUILD_SHARED_LIBS=OFF"
    else:
      line += " -DBUILD_SHARED_LIBS=ON"

    if self.current["coverage"]:
      line += " -DGUM_COVERAGE=ON"
    else:
      line += " -DGUM_COVERAGE=OFF"

    if set(self.modules) == set(cfg.modules.keys()):
      line += " -DBUILD_ALL=ON"
    else:
      line += " -DBUILD_ALL=OFF"
      for module in self.modules:
        line += " -DBUILD_" + module + "=ON"

    if self.current["fixed_seed"]:
      line += " -DGUM_RANDOMSEED=" + cfg.fixedSeedValue
    else:
      line += " -DGUM_RANDOMSEED=0"

    line += " -DBUILD_PYTHON=OFF"

    if self.current["threads"] == "omp":
      line += " -DCMAKE_GUM_THREADS=omp"
    else:
      line += " -DCMAKE_GUM_THREADS=stl"

    if self.current["profiling"]:
      line += " -DUSE_PROFILE=ON"
    else:
      line += " -DUSE_PROFILE=OFF"

    match self.current["compiler"]:
      case "mvsc22":
        line += ' -A x64 -G "Visual Studio 17 2022"'
      case "mvsc22_32":
        line += ' -A Win32 -G "Visual Studio 17 2022"'
      case "mvsc19":
        line += ' -A x64 -G "Visual Studio 16 2019"'
      case "mvsc19_32":
        line += ' -A Win32 -G "Visual Studio 16 2019"'
      case "mvsc17":
        line += ' -G "Visual Studio 15 2017 Win64"'
      case "mvsc17_32":
        line += ' -G "Visual Studio 15 2017"'
      case "mvsc15":
        line += ' -G "Visual Studio 14 2015 Win64"'
      case "mvsc15_32":
        line += ' -G "Visual Studio 14 2015"'
      case "mingw64":
        line += ' -G "MinGW Makefiles"'
      case "clang":
        if self.current["clangpath"] != "":
          clangp = os.path.join(self.current["clangpath"], "clang")
        else:
          clangp = "clang"
        line += f" -DCMAKE_C_COMPILER={clangp} -DCMAKE_CXX_COMPILER={clangp}++"
      case _:  # gcc
        if self.current["gccpath"] != "":
          gccp = os.path.join(self.current["gccpath"], "g")
        else:
          gccp = "g"
        line += f" -DCMAKE_C_COMPILER={gccp}cc -DCMAKE_CXX_COMPILER={gccp}++"

    return line.replace("\\", "/")  # ensure we have unix style paths

  def build_makeForMsBuildSystem(self) -> str:
    line = cfg.msbuild
    match self.current["action"]:
      case "test":
        line += f' agrum.sln /t:gumTest /p:Configuration="{self.current["mode"]}"'
      case "install":
        line += f' INSTALL.vcxproj /p:Configuration="{self.current["mode"]}"'
      case "lib":
        line += f' INSTALL.vcxproj /p:Configuration="{self.current["mode"]}"'
      case _:
        critic(
          f"Action [{self.current['action']}] not treated for target [aGrUM] for now in this compiler weird world."
        )

    line += f" /p:BuildInParallel=true /maxcpucount:{self.current['jobs']}"
    return line

  def build_makeForMakeSystem(self) -> str:
    line = cfg.make

    match self.current["action"]:
      case "test":
        line += " gumTest"
      case "install":
        line += " install"
      case "uninstall":
        line += " uninstall"
      case "lib":
        pass  # nothing to do
      case "doc":
        line += " doc"
      case _:
        critic(f"Action [{self.current['action']}] not treated for now")

    line += f" -j {self.current['jobs']}"
    return line

  def build_make(self):
    if platform.system() == "Windows" and self.current["compiler"] != "mingw64":
      return self.build_makeForMsBuildSystem()
    else:
      return self.build_makeForMakeSystem()

  def build_post(self) -> str:
    line = ""
    if self.current["action"] == "test":
      if cfg.os_platform == "win32":
        if self.current["compiler"] == "mingw64":
          line = "src\\gumTest.exe"
        else:
          line = f"src\\{self.current['mode']}\\gumTest.exe"
      else:
        line = "src/gumTest"

    return line

  def build(self):
    prefix = "build ⮕ " + self.current["mode"] + " ⮕️ "
    self.run_start(prefix)

    safe_cd(self.current, "build")
    safe_cd(self.current, "aGrUM")
    safe_cd(self.current, cfg.buildPath[self.current["mode"]])

    err = False
    gc = gm = gb = 0
    t0 = time.time()
    if self.current["build"] == "all":
      self.run_start(prefix + "cmake")
      cmake_cde = self.build_cmake()
      err = err or 0 < self.execFromLine(cmake_cde, checkRC=False)
    t1 = time.time()
    if not err and self.current["build"] != "no-make":
      self.run_start(prefix + "make")
      make_cde = self.build_make()
      err = err or 0 < self.execFromLine(make_cde, checkRC=False)
    t2 = time.time()

    if not err:
      self.run_start(prefix + "post")
      post_cde = self.build_post()
      err = err or 0 < self.execFromLine(post_cde, checkRC=False)
    t3 = time.time()

    gc = t1 - t0
    gm = t2 - t1
    gb = t3 - t2

    safe_cd(self.current, "..")
    safe_cd(self.current, "..")
    safe_cd(self.current, "..")

    self.conclude(gc, gm, gb)
    if not err:
      self.run_done(prefix)
    else:
      self.run_failed(prefix)

    return not err
