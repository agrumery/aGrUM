/*-------------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
  -------------------------------------------------------------------------*/

-->begin

#if !defined(SKOOL_COCO_PARSER_H__)
#define SKOOL_COCO_PARSER_H__

-->headerdef

#include <agrum/prm/skool/Scanner.h>
using namespace std;

-->namespace_open

class Errors {
  public:
    int count;			// number of errors detected

    Errors();
    void SynErr(std::string file, int line, int n);
    void Error(std::string file, int line, const wchar_t *s);
}; // Errors

class Parser {
  private:
    -->constantsheader
      Token *dummyToken;
    int errDist;
    int minErrDist;

    void SynErr(int n);
    void Get();
    void Expect(int n);
    bool StartOf(int s);
    void ExpectWeak(int n, int follow);
    bool WeakSeparator(int n, int syFol, int repFol);

  public:
    Scanner *scanner;
    Errors  *errors;

    Token *t;   // last recognized token
    Token *la//; he adds a ;   // lookahead token

    -->declarations
    Parser(Scanner *scanner);
    ~Parser();
    void SemErr(const wchar_t* msg);

    -->productionsheader
      void Parse();

}; // end Parser

-->namespace_close
#endif // !defined(SKOOL_COCO_PARSER_H__)

-->implementation
/*----------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
  -----------------------------------------------------------------------*/
-->begin

#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"


-->namespace_open

void Parser::SynErr(int n) {
  if (errDist >= minErrDist) errors->SynErr(scanner->filename, la->line, n);
  errDist = 0;
}

void Parser::SemErr(const wchar_t* msg) {
  if (errDist >= minErrDist) errors->Error(scanner->filename, t->line, msg);
  errDist = 0;
}

void Parser::Get() {
  for (;;) {
    t = la;
    la = scanner->Scan();
    if (la->kind <= maxT) { ++errDist; break; }
    -->pragmas
      if (dummyToken != t) {
        dummyToken->kind = t->kind;
        dummyToken->pos = t->pos;
        dummyToken->col = t->col;
        dummyToken->line = t->line;
        dummyToken->next = NULL;
        coco_string_delete(dummyToken->val);
        dummyToken->val = coco_string_create(t->val);
        t = dummyToken;
      }
    la = t;
  }
}

void Parser::Expect(int n) {
  if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
  if (la->kind == n) Get();
  else {
    SynErr(n);
    while (!StartOf(follow)) Get();
  }
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
  if (la->kind == n) {Get(); return true;}
  else if (StartOf(repFol)) {return false;}
  else {
    SynErr(n);
    while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
      Get();
    }
    return StartOf(syFol);
  }
}

-->productions

void Parser::Parse() {
  t = NULL;
  la = dummyToken = new Token();
  la->val = coco_string_create(L"Dummy Token");
  Get();
  -->parseRoot
    Expect(0);
}

Parser::Parser(Scanner *scanner) {
  -->constants
    dummyToken = NULL;
  t = la = NULL;
  minErrDist = 2;
  errDist = minErrDist;
  this->scanner = scanner;
  errors = new Errors();
}

bool Parser::StartOf(int s) {
  const bool T = true;
  const bool x = false;

  -->initialization

    return set[s][la->kind];
}

Parser::~Parser() {
  delete errors;
  delete dummyToken;
}

Errors::Errors() {
  count = 0;
}

void Errors::SynErr(std::string filename, int line, int n) {
  wchar_t* s;
  switch (n) {
    -->errors
    default:
    {
      wchar_t format[20];
      coco_swprintf(format, 20, L"error %d", n);
      s = coco_string_create(format);
    }
    break;
  }
  wprintf(L"%s|%d| syntax error: %ls\n", filename.c_str(), line, s);
  coco_string_delete(s);
  count++;
}

void Errors::Error(std::string filename, int line, const wchar_t *s) {
  wprintf(L"%s|%d| error: %ls\n", filename.c_str(), line, s);
  count++;
}

-->namespace_close

$$$
