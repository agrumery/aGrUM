#!/usr/bin/python
# -*- coding: utf-8 -*-

#***************************************************************************
#*   Copyright (C) 2010 by Pierre-Henri WUILLEMIN                          *
#*   {prenom.nom}_at_lip6.fr                                               *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU General Public License as published by  *
#*   the Free Software Foundation; either version 2 of the License, or     *
#*   (at your option) any later version.                                   *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU General Public License for more details.                          *
#*                                                                         *
#*   You should have received a copy of the GNU General Public License     *
#*   along with this program; if not, write to the                         *
#*   Free Software Foundation, Inc.,                                       *
#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
#***************************************************************************
from __future__ import print_function
import sys,os,re,glob,math,io

import shelve
from optparse import OptionParser
from datetime import datetime
from distutils import sysconfig
from sys import argv
from subprocess import Popen, PIPE, call
from threading import Thread








##########################################################################################################################


##########################################################################################################################


##########################################################################################################################




##########################################################################################################################



##########################################################################################################################

##########################################################################################################################
def schedule(act,arg,exec_cde=False):
    global sh,sh_no_exec

    sh.append({'action':act,'argument':arg})
    if not exec_cde:
      sh_no_exec.append({'action':act,'argument':arg})

    # safe_cd =>  # cde="[ ! -d "+folder+" ] && mkdir "+folder+" ; cd "+folder
    # cd .. ou autre
    # autre


def special_execute(action,argument):
  if action=="safe_cd":
    if not os.path.exists(argument):
      os.mkdir(argument)
    os.chdir(argument)
  elif action=="back":
    os.chdir("..")
  elif action=="cd":
    os.chdir(argument)
  else:
    return False

  return True

def execute(actions,options):
  nberr=0
  for k in actions:
    if options.verbose:
      print(WARNING+k['action']+' '+OKGREEN+k['argument']+ENDC)

    action=k['action']
    argument=k['argument']

    if not special_execute(action,argument):
      commande=action+" "+argument
      if options.no_fun:
        rc=call(commande,shell=True)
      else:
        rc=threaded_execution(commande,options.verbose)

      if rc>0:
        print("** exit code ="+str(rc))
        return

      #for line in proc.stderr.readlines():
      #  sys.stdout.write(ERROR+line+ENDC)

def execute_test_with_stats(actions,i,nbr_tests_for_stats):
  time_line=re.compile(r'## Profiling :\s+(.*?)\sms ##')
  stat_line=re.compile(r"Failed (.*?) of (.*?) test")

  tps=0
  for k in actions:

    action=k['action']
    argument=k['argument']

    if not special_execute(action,argument):
      commande=action+" "+argument
      proc=Popen(commande,shell=True,stdout=PIPE,stderr=STDOUT)
      out=proc.stdout.readlines()
      tps=0
      failed=0
      total=-1
      for line in out:
        time_match = time_line.search(line)
        if time_match:
          tps=int(time_match.groups()[0])
          continue

        stat_match = stat_line.search(line)
        if stat_match:
          failed=int(stat_match.groups()[0])
          total=int(stat_match.groups()[1])

      if total>=0:
        print("Stats {5}{3}/{4}{6} : succes rate {7}{0}/{1}{6} in {8}{2}{6} ms".format(total-failed,total,tps,i+1,nbr_tests_for_stats,OKGREEN,ENDC,WARNING,ERROR))

  return tps
##########################################################################################################################

def cleanAll():
    import shutil
    print(WARNING+" cleaning"+ENDC+" ... ",end="")
    sys.stdout.flush()
    #os.system("rm -rf build") #
    if os.path.isdir("build"):
      shutil.rmtree("build")
      print(OKGREEN+"done"+ENDC)
    else:
      print(OKGREEN+"nothing to do"+ENDC)
    print()

##########################################################################################################################
def showAll():
    global persistent
    print("Actual options/args")
    print("-------------------")
    for key in persistent:
        if key in ['cleanAll']: # keys we do not need to show
            continue
        print("  "+key+" : "+persistent[key].__str__())
    print("-------------------")
    print()


##########################################################################################################################
def safe_cd(folder):
    schedule("safe_cd",folder)

##########################################################################################################################
def checkConstraints(parser,options,args):
    global current,persistent
    global list_rules,list_options,list_wrappers

    current['verbose']=options.verbose
    current['static_lib']=options.static_lib
    current['platform']=options.platform
    current['destination']=options.destination
    current['jobs']=options.jobs
    current['fixed_seed']=options.fixed_seed
    current['no_fun']=options.no_fun
    current['stats']=options.stats
    current['1by1']=options.oneByOne
    current['test_base']=options.test_base
    current['testlist']=options.testlist
    current['pyversion']=options.pyversion

    for key in 'rule option wrapper'.split():
        current[key]=''

    if len(args) >0: # no args for cdline, just options
        for arg in args:
            if arg in list_rules:
                current['rule']=arg
                continue
            if arg in list_options:
                current['option']=arg
                continue
            if arg in list_wrappers:
                current['wrapper']=arg
                continue
            parser.error(arg+" is an invalid argument")
    else:
        for key in 'rule option wrapper'.split():
          if key in persistent:
            current[key]=persistent[key]
          else:
            current[key]=""

    if current['option']=='':
        current['option']='release'
    if current['rule']=='' and current['wrapper']!='':
        current['rule']='wrapper'
    #if current['option']=='debug':
    #    if current['rule']=='agrum':
    #        current['rule']='agrum-dbg'

    if current['wrapper']!="":
        if (not current['rule'] in ["wrapper", "install","test","uninstall"]):
            parser.print_help()
            parser.error("incompatibilty ²between options <rule>='"+current['rule'] +"' and <wrapper>='"+current['wrapper']+"'")
        if current['option']!='release':
            parser.print_help()
            parser.error('no debug mode for wrappers compilation')

    if current['platform']=='windows':
        if not current['rule'] in ["agrum","test","run","clean",'package','install']:
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <rule>='"+current['rule']+"'")
        if not current['option']=='release':
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <option>='"+current['option']+"'")


##########################################################################################################################
def proceed(options,RANDOMSEED_FOR_FIXED_SEED="10"):
    global listOfModules

    folders=cmake_options=make_options=run_cde =""

    if options['wrapper']!="": # we know rule in ["install","wrapper", "test"]
        folders=['build','wrappers',options['wrapper']]
        cmake_options="-DCMAKE_BUILD_TYPE=RELEASE ../../../wrappers/"+options['wrapper']+"/"

        if (options['pyversion'])=="2":
          cmake_options+=" -DFOR_PYTHON2=ON"
        else:
          cmake_options+=" -DFOR_PYTHON2=OFF  "

        if options['rule'] in ["install"]:
            make_options=options['rule']
        else:
            make_options=""
        if options['rule']=='test':
            if options['wrapper']=='pyAgrum':
			  if os_platform=="win32":
				run_cde=exe_python+" ..\..\\..\\wrappers\\pyAgrum\\testunits\\TestSuite.py"
			  else:
				run_cde=exe_python+" ../../../wrappers/pyAgrum/testunits/TestSuite.py"
            else:
              print(ERROR+"No tests for "+options['wrapper']+ENDC)
              sys.exit(0)
        else:
            run_cde=""
    else:
        option_fixed_seed=" -DGUM_RANDOMSEED="+(RANDOMSEED_FOR_FIXED_SEED if options['fixed_seed'] else "0")
        cmake_options=option_fixed_seed ;

        if options['rule']=='package':
            folders=["build",'package_'+options['platform'],options['option']]
        elif options['rule']=='config':
            folders=["build",options['platform'],'config']
        else:
            folders=["build",options['platform'],options['option']]
        cmake_options+=" -DCMAKE_BUILD_TYPE="+options['option'].upper()+" ../../../src"
        if (options['rule']=="test" or options['rule']=="run"):
            if options['rule']=="test":
              testcde="gumTest"
              make_options="gumTest"
            else:
              testcde="run"
              make_options="run"
            if (options['platform'] != "windows"):
              run_cde="./"+testcde
            else:
              run_cde=".\\"+testcde+".exe"
        else:
          if (options['rule']=="agrum" and options['option'].upper()=="DEBUG"):
            make_options="agrum-dbg"
          else:
            make_options=options['rule']

        # MANAGING MODULES
        listM=[x.upper() for x in options['module'].split('+')]
        setM=set(listM)

        create_build = lambda module: " -DBUILD_"+module+"="+ ("ON" if module in setM else "OFF")
        cmake_options += create_build("ALL")
        for module in listOfModules:
          cmake_options += create_build(module)


    cmake_options+=" -DCMAKE_INSTALL_PREFIX="+options['destination']

    cmake_options+=" -DCMAKE_VERBOSE_MAKEFILE="
    if (options['verbose']):
        cmake_options+="ON"
    else:
        cmake_options+="OFF"

    cmake_options+=" -DBUILD_SHARED_LIBS="
    if (options['static_lib']):
        cmake_options+="OFF"
    else:
        cmake_options+="ON"

    make_options=make_options+" -j "+options['jobs'].__str__()

    [safe_cd(s) for s in folders]
    schedule(CMAKE,cmake_options)
    if options['rule']!='config':
        schedule(MAKE,make_options)
    if (run_cde!=""):
        schedule(run_cde,"",exec_cde=True)
    [schedule("back","") for s in folders]

##########################################################################################################################
def uninstall(options):
    if options['wrapper']!='':
        install_folder=options['destination'] #sysconfig.get_python_lib(1,0,prefix=install_folder)
        print("suppresion récursive de "+ERROR+install_folder+"/pyAgrum"+ENDC)
        os.system('cd '+install_folder+' && rm -rf pyAgrum')
        print("suppresion récursive de "+ERROR+install_folder+"/gumLib"+ENDC)
        os.system('cd '+install_folder+' && rm -rf gumLib')
        print("suppresion de "+ERROR+install_folder+"/pyAgrum*.egg-info"+ENDC)
        os.system('rm -f '+install_folder+"/pyAgrum*.egg-info")
    else:
        folders=["build",options['platform'],options['option']]
        [safe_cd(s) for s in folders]
        schedule("make","uninstall")
        [schedule("back","") for s in folders]

###################################################################################################################



def checkAgrumMemoryLeak(x):
  commande='act test debug -t {0}'.format(x)

  first=WARNING+format(x)+ENDC+" : "
  flag=0

  print(WARNING+format(commande)+ENDC+" : ",end="")
  sys.stdout.flush()
  proc=Popen(commande+" --no-fun",shell=True,stdout=PIPE,stderr=STDOUT)
  out=proc.stdout.readlines()
  for line in out:
    if "NO MEMORY LEAK" in line:
      last=OKGREEN+"ok"+ENDC
      flag=1
    elif "Memory leaks found" in line:
      last=ERROR+line.split("|")[2].strip()+ENDC
      flag=2

  if flag==0:
    last=ERROR+"?"+ENDC

  print(last)
  return (first+last,flag==1)

def checkAgrumMemoryLeaks():
  print("Searching leaks test by test (may be a bit long).\n")
  res=[]
  for x in sorted([CrossPlatformRelPath(x,"src/testunits").split('/')[1].split('TestSuite')[0]
                   for x in glob.glob('src/testunits/module_*/*TestSuite.h')]):
    (msg,testOK)=checkAgrumMemoryLeak(x)
    if not testOK:
      res.append(msg)

  print("\n"+WARNING+"Test(s) with problem(s) :\n -{0}\n".format("\n -".join(res) if len(res)>0 else "none")+ENDC)

##########################################################################################################################

listOfModules=parseModulesTxt(modulesFile)

default={}
current={}
persistent={}


default['platform']="linux"
default['option']="release"
default['rule']="agrum"
default['destination']="/usr"
default['wrapper']=""
default['jobs']="5"
default['test_base']=True
default['verbose']=False
default['static_lib']=False
default['fixed_seed']=False
default['no_fun']=False
default['stats']=False
default['1by1']=False
default['module']='ALL'
default['testlist']='all'
default['pyversion']="3"

not_persistent_options=['fixed_seed','stats','static_lib']

shlv=shelve.open(".options.mak.py",writeback=True)

if shlv.has_key('persistent'):
    persistent=shlv['persistent']
#except:
#  pass

#shlv=shelve.open(".options.mak.py",writeback=True)
#if shlv.has_key('persistent'):
#    persistent=shlv['persistent']

for key in default.iterkeys():
  if not key in not_persistent_options:
    if key in persistent:
        current[key]=persistent[key]
    else:
        current[key]=default[key]

parser=initParser(current)
(options, args)=parser.parse_args()

if options.oneByOne:
  checkAgrumMemoryLeaks()
  sys.exit(0)

checkConstraints(parser,options,args)

if options.no_fun:
  OKGREEN = ''
  WARNING = ''
  ERROR = ''
  ENDC = ''


if exe_python3 is None and exe_python2 is None:
  # should not be possible : we are in a python script :)
  print("No python interpreter found")
  sys.exit(0)
else:
  if options.pyversion=="3":
    if exe_python3 is not None:
      exe_python=exe_python3
    else:
      print("python interperter: python2 (python3 not found)")
      current["pyversion"]="2"
      exe_python=exe_python2
  else:
    if exe_python2 is not None:
      exe_python=exe_python2
    else:
      print("python interperter: python3 (python2 not found)")
      current["pyversion"]="3"
      exe_python=exe_python3

moduleManagement(options.module)

print(getInvocation(current))
print

if options.testlist!="":
    testManagement(options.testlist)

checkTestListCmake()
#needed for cmake
if not os.path.exists('src/testunits/testList.cmake'):
    writeTestList(allTests())

global sh,sh_no_exec
sh=[];
sh_no_exec=[]

## SPECIAL RULES
if current['rule']=='show':
    showAll()
    sys.exit(0)
if current['rule']=='clean':
    cleanAll()
    sys.exit(0)
if current['rule']=='uninstall':
    uninstall(current)
    execute(sh,options)
    sys.exit(0)

if current['rule']=='default':
    current=default
    print(getInvocation(current))

for key in current:
  if not key in not_persistent_options:
    persistent[key]=current[key]
shlv['persistent']=persistent
shlv.sync()
shlv.close()


proceed(current,RANDOMSEED_FOR_FIXED_SEED="10")

if not(current['stats']):
  execute(sh,options)
else:
  execute(sh_no_exec,options)

  print("###########################################")
  print("Processing profile for "+getInvocation(current))
  print("This will take a certain amount of time ...")
  print("###########################################")
  vals=list()
  for i in range(nbr_tests_for_stats):
    vals.append(execute_test_with_stats(sh,i,nbr_tests_for_stats))

  s=0.0
  s2=0.0
  for v in vals:
    s+=v
    s2+=v*v
  mean=s/nbr_tests_for_stats
  var=s2/nbr_tests_for_stats-mean*mean
  print("=======================")
  print("Mean :{0}".format(mean))
  print("StdDev :{0}".format(math.sqrt(var)))
